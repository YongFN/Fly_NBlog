[{"title":"Less文档学习","url":"/Fly_NBlog/2021/12/04/Less%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/","content":"概览Less （Leaner Style Sheets 的缩写） 是一门向后兼容的 CSS 扩展语言\n变量（Variables）@width: 10px;\t//@符号声明变量@height: @width + 10px;#header &#123;    width: @width;    height: @height;&#125;\n\n编译为：\n#header &#123;    width: 10px;    height: 10px;&#125;\n\n混合&#x2F;混入（Mixins）\n混合（mixins）是将一组属性从一个规则集混入到另一个规则集的方法。例：我们定义一个class如下\n.bordered &#123;\tborder-top: dotted 1px black;    border-bottom: solid 2px black;&#125;\n\n我们希望在另一个规则集中使用上面规则集的属性，只需输入所需属性的class名称，如下所示：\n#menu a &#123;\tcolor: #111;\t.bordered();\t//使用上述class的属性&#125;.post a &#123;    color: red;    .bordered();\t//使用上述class的属性&#125;\n\n\n补充：CSS选择器权重\n\n\n\n类型\n权重\n\n\n\n!important\n无穷\n\n\n行内样式(style&#x3D;”width:20px;…..”)\n1000\n\n\nid\n100\n\n\nclass &#x2F; 属性选择符 &#x2F; 伪类\n10\n\n\n标签\n1\n\n\n通配符\n0\n\n\n\n\n\n嵌套（Nesting）模仿HTML的组织结构，使代码更加简洁明了\n#header &#123;    color: black;    .nav &#123;        font-size: 12px;    &#125;    .logo &#123;        width: 300px;    &#125;&#125;\n\n还可以将 伪类选择器（pseudo-selectors）与混入（mixins）一同使用，下面是一个经典的 clearfix 技巧，重写为一个混入（mixins）（&amp; 表示当前选择器的父级）：\n.clearfix &#123;    display: block;    zoom: 1;        &amp;::after &#123;        content: &#x27;&#x27;;        display: block;        font-size: 0;        height: 0;        clear: both;        visibility: hidden;    &#125;&#125;\n\n@规则嵌套和冒泡@ 规则（例如 @media 或 @supports）可以与选择器以相同的方式进行嵌套。@规则会被放在前面，在同一规则集中的其他元素的相对顺序保持不变。这叫做冒泡（bubbling）\n.component &#123;    width: 30px;    @media (min-width: 768px)&#123;        width: 600px;        @media (min-resolution: 192dpi)&#123;\t\t\tbackground-image: linear-gradient(45deg,transparent 5%,transparent 5%);        &#125;    &#125;    @media (min-width: 1280px)&#123;        width: 800px;    &#125;&#125;\n\n编译为：\n.component &#123;    width: 300px;&#125;@media (min-width: 768px)&#123;\t.component &#123;    \twidth: 600px;\t&#125;&#125;@media (min-width: 768px) and (min-resolution: 192dpi)&#123;    .componetn &#123;        background-image: linear-gradient(45deg,transparent 5%,transparent 5%);    &#125;&#125;@media (min-width: 1280px)&#123;    .component: &#123;        width: 800px;    &#125;&#125;\n\n运算（Operations）算术运算符：+、-、*、/ 可以对任何 数字、颜色 或 变量进行运算。\n算术运算符在 加、减 之前会进行单位换算，计算结果以最左侧操作数的单位类型为准，如果单位换算无效或失去意义，则忽略。无效的单位换算例如：\npx 到 cm 或 rad 到 % 的转换\n//所有操作数被转换成相同的单位@conversion-1: 5cm + 10mm;\t//6cm@conversion-2: 2 - 3cm - 5mm;\t//-1.5cm//conversion is impossible（转换无效）@incompatible-units: 2 + 5px - 3cm;//example with variables（变量示例）@base: 5%;@filler: @base * 2;@other: @base + @filler;\n\n乘法和除法不作转换，这两种运算在大多数情况下都没有意义，一个长度乘以一个长度就得到一个区域，而CSS是不支持指定区域的。Less将按数字的原样进行操作，并将为计算结果指定明确的单位类型。\n@base: 2cm * 3mm;\t//6cm\n\n可以对颜色进行算术运算：\n@color: #224488 /2;\t//#112244background-color: #112244 + #111;\t//#223355\n\ncalc() 特例\n为了与CSS保持兼容，calc()并不对数学表达式进行计算，但是在嵌套函数中会计算变量和数学公式的值。\n@var: 50vh/2;width: calc(50% + (@var - 20px));\t//calc(50% + (25vh - 20px))\n\n转义（Escaping）转义（Escaping）允许你使用任意字符串作为属性或变量值。任何 ~&quot;anything&quot; 或 ~&#39;anything&#39; 形式的内容都将按原样输出，除非 interpolation \n@min768: ~&quot;(min-width: 768px)&quot;;.element &#123;    @media @min768&#123;        font-size: 1.2rem;    &#125;&#125;\n\n编译为：\n@media (min-width: 768px)&#123;    .element &#123;        font-size: 1.2rem;    &#125;&#125;\n\n注意，从Less3.5开始，可以简写为：\n@min768: (min-width: 768px);.element&#123;    @media @min768 &#123;        font-size: 1.2rem;    &#125;&#125;\n\n在Less3.5+版本中，许多以前需要&quot;引号转义&quot;的情况就不再需要了\n函数（Function）Less内置了多种函数用于转换颜色、处理字符串、算术运算等，这些函数在后面会详细学习。\n函数的用法非常简单，举个例子：\n@base: #f04615;@width: 0.5;.class &#123;    width: percentage(@width);    color: saturate(@base,5%);    background-color: spin(lighten(@base,25%),8);&#125;\n\n\npercentage函数将0.5 转化为 50%\nsaturate函数将颜色饱和度增加 5%\nlighten函数将颜色亮度降低 25%\nspin函数将色相值增加 8\n\n映射（Maps）从Less3.5开始，可以将混入（mixins）和规则集（rulesets）作为一组值的映射（map）使用。\n#colors()&#123;    primary: blue;    secondary: green;&#125;.button &#123;    color: #colors[primary];    border: 1px solid #colors[secondary];&#125;\n\n输出为：\n.button &#123;\tcolor: blue;    border: 1px solid green;&#125;\n\n作用域（Scope）Less中的作用域与CSS中的类似。首先在本地查找变量和混入（mixins），如果找不到，则从&quot;父&quot;级作用域继承。\n@var: red;#page &#123;    @var: white;    #header &#123;        color: @var;\t//white    &#125;&#125;\n\n混入（mixins）和变量的定义不必在引用之前事先定义。\n@var: red;#page &#123;    #header &#123;        color: @var;\t//white    &#125;    @var: white;&#125;\n\n注释（Comments）块注释和行注释都可以\n/*\t一个块注释 *\tstyle comment\t*/@var: red;// 一行注释@var: white;\n\n导入（Importing）导入一个 .less 文件，此文件中的所有变量就可以全部使用。\n如果导入的文件是 .less扩展名，则可以将扩展名省略\n@import &quot;library&quot;;\t// library.less@import &quot;typo.css&quot;\n\n","categories":["Less"],"tags":["CSS","Less"]},{"title":"Linux（一）","url":"/Fly_NBlog/2023/06/14/Linux%EF%BC%88%E4%B8%80%EF%BC%89/","content":"安装通过虚拟机安装，相关软件及镜像请百度，本案例使用Centos7\nLinux文件系统结构所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构\n所有文件都存在于根目录下的不同目录中，不同的目录主要用于存放不同类型的文件\n当前目录：./\n上一层目录：../\n默认不查找.开头的文件，例如.env文件\n主要目录\n\n\n目录\n作用\n\n\n\n/bin\n存放系统常用的命令和可执行文件\n\n\n/boot\n存放系统启动配置文件和内核镜像\n\n\n/dev\n存放系统设备文件\n\n\n/etc\n存放系统配置文件\n\n\n/home\n用户的主目录\n\n\n/lib\n存放共享程序库文件\n\n\n/media\n存放可移动设备挂载点\n\n\n/mnt\n存放临时文件系统挂载点\n\n\n/opt\n第三方应用程序安装目录\n\n\n/root\nroot用户的根目录\n\n\n/sbin\n存放只有管理员才能运行的命令\n\n\n/srv\n存放特定服务的数据\n\n\n/tmp\n存放临时文件\n\n\n/usr\n存放系统范围的应用程序和数据\n\n\n/var\n存放可变数据，如日志文件\n\n\n命令行操作常用命令\n\n\n命令\n作用\n\n\n\ncd\n切换目录\n\n\nls\n列出当前目录中的文件 -a 显示所有文件; -l 显示文件详细信息 \n\n\ntouch\n新建文件 -m 修改文件的修改日; -a为文件添加或修改访问时间; -t指定文件时间戳\n\n\nmkdir\n新建目录\n\n\nrm\n删除文件；-r 递归删除文件夹和所有子文件; -f 强制删除; -i 询问用户是否确认\n\n\ncp\n复制文件 -r 递归复制; -f 强制覆盖; -i 询问用户\n\n\nmv\n移动或重命名文件 -f、-i\n\n\ncat\n将文件内容输出到终端\n\n\necho\n输出文本到终端\n\n\ngrep\n在文件中查找匹配的文本\n\n\nchmod\n修改文件权限\n\n\npwd\n查看当前完整路径\n\n\nchmod：\n\nu/g/o/a: 分别指定权限修改对象为[用户]/[组]/[其他人]/[所有人]\n+/-: 增加或取消权限\nr/w/x: 分别代表读取、写入、执行权限\n数字模式：chmod 644 test.txt，将 test.txt 文件权限修改为 -rw-r--r--\n\n用户账号和权限管理\n\n\n命令\n作用\n\n\n\nuseradd\n创建用户账号\n\n\npasswd\n修改用户密码\n\n\nusermod\n修改用户账号信息\n\n\nuserdel\n删除用户账号\n\n\ngroupadd\n创建用户组\n\n\ngroupmod\n修改用户组信息\n\n\ngroupdel\n删除用户组\n\n\nchmod\n修改文件或目录权限\n\n\n软件包管理\n\n\n命令\n作用\n\n\n\napt-get\nDebian和Ubuntu中的软件包管理工具\n\n\nyum\nRed Hat、Fedora和CentOS中的软件包管理工具\n\n\ndnf\n新一代Fedora中的软件包管理工具\n\n\npacman\nArch Linux中的软件包管理工具\n\n\n\nyum install [package_name]: 安装指定的软件包\nyum update [package_name]: 更新已安装的软件包，找不到则更新全部\nyum remove [package_name]: 从系统中卸载已安装的软件包\nyum info [package_name]: 显示指定软件包的详细信息，包括版本，大小，发布日期等\nyum search [query]: 搜索可以安装的软件包。\nyum list [package_name]: 列出已安装的软件包\nyum upgrade [package_name]: 升级已安装软件包的最新版本\nyum clean all: 清理所有的yum缓存及rpm数据库中的旧数据\nyum groupinstall [group_name]: 安装指定的软件包组\nyum clean packages: 清除缓存目录下的软件包\nyum clean headers: 清除缓存目录下的 headers\nyum clean oldheaders: 清除缓存目录下旧的 headers\nyum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的 headers\n\n软件服务管理service命令可以启动、停止或重启系统服务。\n\nservice [service_name] [command]\n\n#Apache Web服务service httpd startservice httpd stopservice httpd restartservice httpd reloadservice httpd try-restartservice httpd status\n\nsystemctlsystemctl是Linux中最新的服务管理工具。它可以将服务状态更精确地监控和控制，可以在系统引导时自动启动服务\n例：systemctl start service_name\n\nstart\nstop\nrestart\n#启用一个服务，在系统引导时自动启动enable\n#禁用一个服务，系统引导时不启动disable\nstatus\n\nchkconfigchkconfig工具是一种管理服务的方式，它可以在系统启动时自动启动服务\nchkconfig [service_name] [command]chkconfig httpd onchkconfig httpd off查询已启用和未启用的服务chkconfig --list\n\n常用基本网络配置ifconfigifconfig可以用来显示已配置的网络接口信息。\n例如，要查看所有网络接口的信息，可以使用以下命令：\nifconfig -a\n\n\n\n要启用或禁用一个网络接口：\nifconfig eth0 up/down\n\nipip命令比ifconfig命令更加强大和灵活，可以用来设置和显示网络接口。\n例如，要查看所有网络接口的信息，可以使用以下命令：\nip addr show\n\n\n\n要启用或禁用一个网络接口：\nip link set eth0 up/down\n\n\n\nrouteroute命令用于配置网络路由表和查看路由信息\n例如，要查看当前路由信息，可以使用以下命令：\nroute -n\n\n\n\n要添加路由信息：\nroute add default gw [gateway_ip] [interface]\n\n\n\n例如，要将默认网关设置为192.168.1.1，可以使用以下命令：\nroute add default gw 192.168.1.1\n\n\n\nping用于测试网络连接是否正常\n例如，要测试与google.com的连通性：\nping google.com\n\nhostnamehostname命令用于显示或设置系统主机名。例如，要显示当前主机名：\nhostname\n\n\n\n要设置新的主机名：\nhostname [new_host_name]\n\n\n\n例如，要将主机名设置为example.com，可以使用以下命令：\nhostname example.com\n\n打包和压缩zipzip：压缩文件或目录\n选项-r：压缩目录\nzip myzip.zip s1.txt s2.txt\n\nunzip：解压缩\n选项-d：指定解压缩位置，默认在当前目录\nunzip -d /home/my/abc/ myzip.zip\n\ngz不能打包\n选项：\n\n-c ：将压缩数据输出到标准输出中，可以用于保留源文件\n-d：解压缩\n-r：压缩目录（除了目录本身）\n\ngzip -c abc.txt &gt; abc.txt.gz\n\ngunzip：解压缩\ngunzip abc.txt.gz\n\nbz2bzip2：不能压缩目录\n选项：\n\n-d：解压缩\n-k：压缩时保留源文件\n-v：显示压缩的详细信息\n\nbzip2 -k abc.txt\n\nbunzip2：解压缩\nbunzip2 abc.txt.bz2\n\ntar打包不压缩\ntar打包：\n\n-c：打包\n-f：指定压缩包的文件名\n-v：显示打包过程\n\ntar -cvf mytar.tar file1.txt file2.txt\n\ntar解打包：\n\n-x：解打包\n-f：指定压缩包文件名\n-v：显示解包过程\n\ntar -xvf mytar.tar\n\ntar.gz和tar.bz2使用tar\n选项：\n\n-z：压缩和解压缩.tar.gz\n-j：压缩和解压缩.tar.bz2\n\n","categories":["Linux"],"tags":["Linux"]},{"title":"Linux（三）","url":"/Fly_NBlog/2023/06/16/Linux%EF%BC%88%E4%B8%89%EF%BC%89/","content":"Shell入门shell中0表示true\n执行脚本Shell脚本通常以.sh结尾，执行脚本命令\nbash myscript.sh\n\n定义变量变量使用美元符号$来引用，通过使用 = 运算符将值分配给变量\nNAME=&quot;John&quot;# 引用变量NAMEecho &quot;My name is $NAME!&quot;\n\n读取用户输入使用read命令可以从键盘上读取用户输入\necho &quot;What is your name?&quot;read NAMEecho &quot;Hello, $NAME!&quot;\n\n流程控制if-else如果 else 分支没有语句执行，就不要写这个 else\n使用[...]时，大于使用 -gt，小于使用 -lt\nif [ $AGE -lt 18 ]then    echo &quot;You are not old enough to vote.&quot;else    echo &quot;You can vote.&quot;fi\n\n使用((...))时，可以直接使用&gt;和&lt;\na=10b=20if (( $a == $b ))then   echo &quot;a 等于 b&quot;elif (( $a &gt; $b ))then   echo &quot;a 大于 b&quot;elif (( $a &lt; $b ))then   echo &quot;a 小于 b&quot;else   echo &quot;没有符合的条件&quot;fi\n\ncase…esac与switch...case类似&#96;\necho &#x27;输入 1 到 4 之间的数字:&#x27;echo &#x27;你输入的数字为:&#x27;read aNumcase $aNum in    1)  echo &#x27;你选择了 1&#x27;    ;;    2)  echo &#x27;你选择了 2&#x27;    ;;    3)  echo &#x27;你选择了 3&#x27;    ;;    4)  echo &#x27;你选择了 4&#x27;    ;;    *)  echo &#x27;你没有输入 1 到 4 之间的数字&#x27;    ;;esac\n\n循环forfor loop in 1 2 3 4 5do    echo &quot;The value is: $loop&quot;done\n\nwhileint=1while(( $int&lt;=5 ))do    echo $int    let &quot;int++&quot;done\n\nuntil一般 while 循环优于 until 循环\n直至条件为 true 时停止\na=0until [ ! $a -lt 10 ]do   echo $a   a=`expr $a + 1`done\n\n函数# Define the functionmyfunction() &#123;    echo &quot;Hello from my function!&quot;&#125;# Call the functionmyfunction\n\n函数参数调用函数时可以向其传递参数\n在函数体内部，通过 $n 的形式来获取参数的值\n当n&gt;=10时，需要使用$&#123;n&#125;来获取参数\nfunWithParam()&#123;    echo &quot;第一个参数为 $1 !&quot;    echo &quot;第二个参数为 $2 !&quot;    echo &quot;第十个参数为 $10 !&quot;    echo &quot;第十个参数为 $&#123;10&#125; !&quot;    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;    echo &quot;参数总数有 $# 个!&quot;    echo &quot;作为一个字符串输出所有参数 $* !&quot;&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73\n\n\n\n\n参数\n说明\n\n\n\n$#\n传递到脚本或函数的参数个数\n\n\n$*\n以一个单字符串显示所有向脚本传递的参数\n\n\n$$\n脚本运行的当前进程ID号\n\n\n$!\n后台运行的最后一个进程的ID号\n\n\n$@\n与$*相同，但是使用时加引号，并在引号中返回每个参数。\n\n\n$-\n显示Shell使用的当前选项，与set命令功能相同。\n\n\n$?\n显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。\n\n\nIO重定向和管道使用I&#x2F;O重定向，我们可以将命令的输出或错误重定向到文件或其他命令中。\n输出：\nls &gt; files.txt\n\n错误：\ngrep &quot;pattern&quot; file.txt 2&gt; error.log\n\n管道将一个命令的输出作为下一个命令的输入\ncat file.txt | grep &quot;pattern&quot;\n\n调试使用 -x 选项进行调试，以输出每个被执行的命令和其参数。\nbash -x myscript.sh\n\n命令行选项使用 getopts 命令\nwhile getopts &quot;a:b:&quot; option; do    case &quot;$&#123;option&#125;&quot; in        a) PARAM_A=$&#123;OPTARG&#125;;;        b) PARAM_B=$&#123;OPTARG&#125;;;    esacdone\n\n脚本使用 getopts 命令来解析选项 -a 和 -b，并将提供的值存储在变量 $PARAM_A 和 $PARAM_B 中\n","categories":["Linux"],"tags":["Linux"]},{"title":"Linux（二）","url":"/Fly_NBlog/2023/06/14/Linux%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"磁盘管理常用3个命令：df、du、fdisk\ndf检查文件系统的磁盘空间占用情况\ndf [-akmhHTi] [directory]-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；-k ：以 KBytes 的容量显示各文件系统；-m ：以 MBytes 的容量显示各文件系统；-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；-H ：以 M=1000K 取代 M=1024K 的进位方式；-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；-i ：不用硬盘容量，而以 inode 的数量来显示例df -h /etc\n\n\n\ndudu 命令是对文件和目录磁盘使用的空间的查看\ndu [-ahskm] [directory]-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。-h ：以人们较易读的容量格式 (G/M) 显示；-s ：列出总量而已，而不列出每个各别的目录占用容量；-S ：不包括子目录下的总计，与 -s 有点差别。-k ：以 KBytes 列出容量显示；-m ：以 MBytes 列出容量显示；例du -h /*\n\n\n\nfdisk磁盘分区表操作工具\nfdisk [-l] 装置名称-l: 输出后面接的装置所有的分区内容\n\n\n\n格式化文件系统的格式化\nmkfs [-t 文件系统格式] 文件名\n[root@www ~]# mkfs[tab][tab]mkfs         mkfs.cramfs  mkfs.ext2    mkfs.ext3    mkfs.msdos   mkfs.vfat\n\n\n\n校验fsck检查和维护不一致的文件系统\n若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查\nfsck [-t 文件系统] [-ACay] 装置名称-t : 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数-s : 依序一个一个地执行 fsck 的指令来检查-A : 对/etc/fstab 中所有列出来的 分区（partition）做检查-C : 显示完整的检查进度-d : 打印出 e2fsck 的 debug 结果-p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行-R : 同时有 -A 条件时，省略 / 不检查-V : 详细显示模式-a : 如果检查有错则自动修复-r : 如果检查有错则由使用者回答是否修复-y : 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复。\n\n\n\n挂载与卸载分区完再挂载到已存在的目录\nmount挂载\nmount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点\n\numount卸载\numount [-fn] 装置文件名或挂载点-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；-n ：不升级 /etc/mtab 情况下卸除。\n\n\n\nvi编辑器编辑模式和命令模式\n编辑模式用于编辑文本，因此所有你输入的字符都将直接被插入到文本中\n命令模式允许你执行诸如复制、剪切、粘贴、删除和搜索等各种操作，处于命令模式时，所输入的字符将被视为命令，而不是插入到文本中\n\n默认情况下，vi编辑器进入命令模式。\n进入编辑模式，请单击i键。\n要返回命令模式，请按下 Esc 键。\n底行模式底行模式允许你执行高级的操作，例如保存文件、退出编辑器、显示行号、查找并替换等操作\n进入底行模式，请在命令模式下按:键。输入要执行的命令，然后按 Enter 键\n例：保存并退出编辑器\n:wq\n\n进入与退出vi编辑器filename是你要编辑的文件名\n如果这个文件已经存在，vi将打开这个文件；否则，vi将创建一个新文件并打开它\nvi filename\n\n退出vi编辑器，请在命令模式下按以下键\n:q\n\n对文件进行了更改并想强制退出vi编辑器\n:q!\n\n对文件进行了更改并想保存更改并退出vi编辑器\n:wq\n\n基本编辑插入操作在编辑模式下，可以插入字符和文本\n在一行的结尾插入文本，请按下 a 键。命令模式按下A键会将光标移到当前行的结尾\n删除操作在命令模式下，可以使用删除命令删除文本\n要删除一个字符，请将光标置于该字符上，并按下 x 键\n要删除整行，将光标置于该行并按下 dd 键\n复制和粘贴操作在命令模式下，V 键选择两行\n要复制一行，将光标放在该行并按下 yy 键\n复制一行并将其粘贴到光标的下面，在命令模式下按下p键\n复制选中的文本，先将光标置于文本的起始位置，然后按下 v 键，移动光标并选择文本，直到达到想要的结束位置。接下来，按下 y 键来复制选定的文本\n将选定的文本粘贴到另一处，请将光标置于目标位置并按下p键\n撤销撤销上一次的编辑操作，请按下 u 键。要退回撤销操作，请按下 Ctrl + r 键\n进阶编辑查找和替换在命令模式下，可以使用 :/ 命令进行查找\n:/hello\n\n替换当前光标下的单词，可以按下*键来高亮该单词，然后在底行模式下使用 :s 命令进行替换\n将单词 hello 替换为 world，输入以下命令\n:s/hello/world\n\n注释和缩进在命令模式下，可以使用 &lt; 和 &gt; 命令来缩进或取消缩进选定的行\n","categories":["Linux"],"tags":["Linux"]},{"title":"Redis基本命令与操作","url":"/Fly_NBlog/2023/05/30/Redis%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C/","content":"keyDel\nkey 存在时删除 key。\nredis 127.0.0.1:6379&gt; SET keyName redisOKredis 127.0.0.1:6379&gt; DEL keyName(integer) 1\n\n\n\nDump\n序列化 key ，并返回被序列化的值；key不存在返回nil\nredis 127.0.0.1:6379&gt; SET keyName &quot;hello, dumping world!&quot;OKredis&gt; DUMP greeting&quot;\\x00\\x15hello, dumping world!\\x06\\x00E\\xa0Z\\x82\\xd8r\\xc1\\xde&quot;\n\n\n\nExists\n检查 key 是否存在\nredis 127.0.0.1:6379&gt; EXISTS keyName(integer) 0redis 127.0.0.1:6379&gt; set keyName keyValueOKredis 127.0.0.1:6379&gt; EXISTS keyName(integer) 1\n\n\n\nExpire\n设置 key 的过期时间，以秒为单位\nredis 127.0.0.1:6379&gt; SET msg helloOKredis 127.0.0.1:6379&gt; EXPIRE msg 60(integer) 1# 1分钟后msg会自动删除\n\n\n\nExpireat\n设置 key 的过期时间，以 UNIX 时间戳(unix timestamp)格式设置\nredis 127.0.0.1:6379&gt; SET msg helloOKredis 127.0.0.1:6379&gt; EXPIREAT msg 1293840000(integer) 1redis 127.0.0.1:6379&gt; EXISTS msg(integer) 0\n\n\n\nPExpire\n设置 key 的过期时间，以毫秒为单位\nredis 127.0.0.1:6379&gt; SET msg helloOKredis 127.0.0.1:6379&gt; PEXPIRE msg 1000(integer) 1redis 127.0.0.1:6379&gt; TTL msg(integer) 1redis 127.0.0.1:6379&gt; PTTL msg(integer) 998\n\n\n\nPExpireat\n设置 key 的过期时间，以UNIX 时间戳(unix timestamp)设置，以毫秒计算\nredis 127.0.0.1:6379&gt; SET msg helloOKredis 127.0.0.1:6379&gt; PEXPIREAT msg 1685546807901(integer) 1\n\n\n\nPErsist\n移除给定 key 的过期时间，使 key 永不过期\n移除成功时，返回 1\nkey 不存在或 key 没有设置过期时间，返回 0 \nredis 127.0.0.1:6379&gt; SET keyName &quot;Hello&quot;OKredis 127.0.0.1:6379&gt; EXPIRE keyName 60(integer) 1redis 127.0.0.1:6379&gt; PERSIST keyName(integer) 1\n\n\n\nRename\n修改 key 的名称，成功提示 OK，失败返回一个错误\n# key 存在且 newkey 不存在redis 127.0.0.1:6379&gt; SET message &quot;hello world&quot;OK redis 127.0.0.1:6379&gt; RENAME message msgOK# 当 key 不存在时，返回错误redis 127.0.0.1:6379&gt; RENAME message msg(error) ERR no such key# newkey 已存在时， 会覆盖旧 newkeyredis 127.0.0.1:6379&gt; SET message &quot;hello&quot;OKredis 127.0.0.1:6379&gt; SET msg &quot;world&quot;OKredis 127.0.0.1:6379&gt; RENAME message msgOKredis 127.0.0.1:6379&gt; GET message&quot;world&quot;\n\n\n\nRenamenx\n新的 key 不存在时修改 key 的名称\n修改成功时，返回 1；新的key存在，返回0\nredis 127.0.0.1:6379&gt; SET message &quot;hello&quot;OKredis 127.0.0.1:6379&gt; SET msg &quot;world&quot;OK# 设msg不存在redis 127.0.0.1:6379&gt; RENAMENX message msg(integer) 1# 设msg存在redis 127.0.0.1:6379&gt; RENAMENX message msg(integer) 0\n\n\n\nRandomekey\n从当前数据库中随机返回一个 key \n数据库为空时，返回 nil （windows 系统返回 null）\n# 数据库不为空redis 127.0.0.1:6379&gt;  MSET fruit &quot;apple&quot; drink &quot;beer&quot; food &quot;cookies&quot;OKredis 127.0.0.1:6379&gt; RANDOMKEY&quot;fruit&quot;redis 127.0.0.1:6379&gt; RANDOMKEY&quot;food&quot;# 数据库为空redis 127.0.0.1:6379&gt; RANDOMKEY(null)\n\n\n\nKeys\n查找所有符合给定模式 pattern 的 key \n# 创建一些keyredis 127.0.0.1:6379&gt; SET keyName1 redisOKredis 127.0.0.1:6379&gt; SET keyName2 mysqlOKredis 127.0.0.1:6379&gt; SET keyName3 mongodbOK# 查找以keyName开头的keyredis 127.0.0.1:6379&gt; KEYS keyName*1) &quot;keyName1&quot;2) &quot;keyName2&quot;3) &quot;keyName3&quot;# 获取所有key可使用*redis 127.0.0.1:6379&gt; KEYS *1) &quot;keyName1&quot;2) &quot;keyName2&quot;3) &quot;keyName3&quot;\n\n\n\nMove\n将当前数据库的 key 移动到给定数据库的 db 当中，移动成功返回 1 ，失败则返回 0\n# keyName 存在于当前数据库# redis默认使用数据库 0，为了清晰起见，这里再显式指定一次。redis 127.0.0.1:6379&gt; SELECT 0                             OKredis 127.0.0.1:6379&gt; MOVE keyName 1(integer) 1redis 127.0.0.1:6379&gt; EXISTS keyName(integer) 0# 切换到数据库1查看redis 127.0.0.1:6379&gt; SELECT 1                            OKredis 127.0.0.1:6379&gt; EXISTS keyName(integer) 1\n\n\n\nTTL\n以秒为单位返回 key 的剩余过期时间\nkey 不存在，返回 -2 \nkey 存在，但没有设置剩余生存时间，返回 -1\n# 设msg为key# msg不存在redis 127.0.0.1:6379&gt; TTL msg(integer) -2# msg存在，没有设置过期时间redis 127.0.0.1:6379&gt; TTL msg(integer) -1# msg存在，设置过期时间为60秒redis 127.0.0.1:6379&gt; EXPIRE msg 60(integer) 1redis 127.0.0.1:6379&gt; TTL msg(integer) 59\n\n\n\nPTTL\n以毫秒为单位返回 key 的剩余过期时间\nkey 不存在，返回 -2 \nkey 存在，但没有设置剩余生存时间，返回 -1\nType\n返回 key 所储存的值的类型\n# 字符串redis&gt; SET weather &quot;sunny&quot;OKredis&gt; TYPE weatherstring# 列表redis&gt; LPUSH book_list &quot;programming in scala&quot;(integer) 1redis&gt; TYPE book_listlist# 集合redis&gt; SADD pat &quot;dog&quot;(integer) 1redis&gt; TYPE patset\n\n\n\nstringSet\n设置key的值，key 已经存储其他值， SET 就覆写旧值\nredis 127.0.0.1:6379&gt; SET key &quot;value&quot;OK\n\nGet\n获取key的值， key 不存在时，返回 nil\nredis 127.0.0.1:6379&gt; GET key&quot;value&quot;\n\nGetrange\n获取存储在指定 key 中字符串的子字符串\n字符串的截取范围由 start 和 end 两个偏移量\nredis 127.0.0.1:6379&gt; SET mykey &quot;This is my test key&quot;OKredis 127.0.0.1:6379&gt; GETRANGE mykey 0 3&quot;This&quot;redis 127.0.0.1:6379&gt; GETRANGE mykey 0 -1&quot;This is my test key&quot;\n\nGetset\n置指定 key 的值，并返回 key 旧的值\nredis 127.0.0.1:6379&gt; GETSET mynewkey &quot;This is my test key&quot;(nil)redis 127.0.0.1:6379&gt; GETSET mynewkey &quot;This is my new value to test getset&quot;&quot;This is my test key&quot;\n\nGetbit\n对 key 所储存的字符串值，获取指定偏移量上的位(bit)\n字符串值的长度大，或者 key 不存在时，返回 0\nredis&gt; GETBIT bit 10086(integer) 0redis&gt; SETBIT bit 10086 1(integer) 0 redis&gt; GETBIT bit 10086(integer) 1\n\nMget\n返回所有(一个或多个)给定 key 的值\n某个 key 不存在，那么这个 key 返回特殊值 nil\nredis 127.0.0.1:6379&gt; SET key1 &quot;hello&quot;OKredis 127.0.0.1:6379&gt; SET key2 &quot;world&quot;OKredis 127.0.0.1:6379&gt; MGET key1 key2 someOtherKey1) &quot;Hello&quot;2) &quot;World&quot;3) (nil)\n\nSetbit\n对 key 所储存的字符串值，设置或清除指定偏移量上的位bit\nredis&gt; SETBIT bit 10086 1(integer) 0 redis&gt; GETBIT bit 10086(integer) 1 redis&gt; GETBIT bit 100   # bit 默认被初始化为 0(integer) 0\n\nSetex\n为指定的 key 设置值及其过期时间，如果 key 已经存在， SETEX 命令将会替换旧的值\nredis 127.0.0.1:6379&gt; SETEX mykey 60 redisOKredis 127.0.0.1:6379&gt; TTL mykey60redis 127.0.0.1:6379&gt; GET mykey&quot;redis\n\nSetnx\n指定的 key 不存在时，为 key 设置指定的值\nredis&gt; EXISTS job                # job 不存在(integer) 0 redis&gt; SETNX job &quot;programmer&quot;    # job 设置成功(integer) 1 redis&gt; SETNX job &quot;code-farmer&quot;   # 尝试覆盖 job ，失败(integer) 0 redis&gt; GET job                   # 没有被覆盖&quot;programmer&quot;\n\nSetrange\n用指定的字符串覆盖给定 key 所储存的字符串值\nredis 127.0.0.1:6379&gt; SET key1 &quot;Hello World&quot;OKredis 127.0.0.1:6379&gt; SETRANGE key1 6 &quot;Redis&quot;(integer) 11redis 127.0.0.1:6379&gt; GET key1&quot;Hello Redis&quot;\n\nStrlen\n获取指定 key 所储存的字符串值的长度，当 key 储存的不是字符串值时，返回一个错误\n# 获取字符串的长度 redis&gt; SET mykey &quot;Hello world&quot;OK redis&gt; STRLEN mykey(integer) 11  # 不存在的 key 长度为 0 redis&gt; STRLEN nonexisting(integer) 0\n\nMset\n同时设置一个或多个 key-value 对\nredis 127.0.0.1:6379&gt; MSET key1 &quot;Hello&quot; key2 &quot;World&quot;OKredis 127.0.0.1:6379&gt; GET key1&quot;Hello&quot;redis 127.0.0.1:6379&gt; GET key21) &quot;World&quot;\n\nMsetnx\n所有给定 key 都不存在时，同时设置一个或多个 key-value 对\n# 对不存在的 key 进行 MSETNX redis&gt; MSETNX rmdbs &quot;MySQL&quot; nosql &quot;MongoDB&quot; key-value-store &quot;redis&quot;(integer) 1 redis&gt; MGET rmdbs nosql key-value-store1) &quot;MySQL&quot;2) &quot;MongoDB&quot;3) &quot;redis&quot;  # MSET 的给定 key 当中有已存在的 key redis&gt; MSETNX rmdbs &quot;Sqlite&quot; language &quot;python&quot;  # rmdbs 键已经存在，操作失败(integer) 0 redis&gt; EXISTS language                          # 因为 MSET 是原子性操作，language 没有被设置(integer) 0 redis&gt; GET rmdbs                                # rmdbs 也没有被修改&quot;MySQL&quot;\n\nPsetex\n以毫秒为单位设置 key 的生存时间\nPSETEX mykey 1000 &quot;Hello&quot;OK\n\nAppend\n为指定的 key 追加值\n如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾\n如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样\nredis 127.0.0.1:6379&gt; APPEND KEY_NAME NEW_VALUE\n\nIncr\n将 key 中储存的数字值增一\nSET mykey 10OKINCR mykey(integer) 11GET mykey    # 数字值在 Redis 中以字符串的形式保存&quot;11&quot;\n\nIncrby\n将 key 中储存的数字加上指定的增量值\n如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBY 命令\n如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误\nSET numkey 50OKINCRBY numkey 20(integer) 70GET numkey&quot;70&quot;\n\nIncrbyfloat\n为 key 中所储存的值加上指定的浮点数增量值\n如果 key 不存在，那么 INCRBYFLOAT 会先将 key 的值设为 0 \nSET floatkey 10.50OKINCRBYFLOAT floatkey &quot;10.6&quot;# 值和增量都是指数符号 redis&gt; SET mykey 314e-2OK redis&gt; GET mykey                # 用 SET 设置的值可以是指数符号&quot;314e-2&quot; redis&gt; INCRBYFLOAT mykey 0      # 但执行 INCRBYFLOAT 之后格式会被改成非指数符号&quot;3.14&quot;\n\nDecr\n将 key 中储存的数字值减一。\nSET numkey 10OKDECR numkey(integer) 9\n\nDecrby\nkey 所储存的值减去给定的减量值\nSET numkey 100OKDECRBY numkey 20(integer) 80\n\nhash是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象\nHdel\n删除一个或多个哈希表字段\n指定的字段是否存在。\nHget\n获取哈希表中指定字段的值。\nHgetall\n获取在哈希表中指定 key 的所有字段和值\nHincrby\n为哈希表中的字段值加上指定增量值\n增量也可以为负数，相当于对指定字段进行减法操作\nredis&gt; HSET myhash field 5(integer) 1redis&gt; HINCRBY myhash field 1(integer) 6redis&gt; HINCRBY myhash field -1(integer) 5redis&gt; HINCRBY myhash field -10(integer) -5redis&gt; \n\nHincrbyfloat\n为哈希表中的字段值加上指定浮点数增量值\nredis&gt; HSET mykey field 10.50(integer) 1redis&gt; HINCRBYFLOAT mykey field 0.1&quot;10.6&quot;redis&gt; HINCRBYFLOAT mykey field -5&quot;5.6&quot;\n\nHkeys\n用于获取哈希表中的所有域（field）\nredis 127.0.0.1:6379&gt; HSET myhash field1 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; HSET myhash field2 &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; HKEYS myhash1) &quot;field1&quot;2) &quot;field2&quot;\n\nHlen\n获取哈希表中字段的数量。\nredis 127.0.0.1:6379&gt; HSET myhash field1 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; HSET myhash field2 &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; HLEN myhash(integer) 2\n\nHmget\n用于返回哈希表中，一个或多个给定字段的值\nredis 127.0.0.1:6379&gt; HSET myhash field1 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; HSET myhash field2 &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; HMGET myhash field1 field2 nofield1) &quot;foo&quot;2) &quot;bar&quot;3) (nil)\n\nHmset\n用于为哈希表中的字段赋值\n如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作\n如果字段已经存在于哈希表中，旧值将被覆盖\nredis 127.0.0.1:6379&gt; HSET myhash field1 &quot;foo&quot;OKredis 127.0.0.1:6379&gt; HGET myhash field1&quot;foo&quot;redis 127.0.0.1:6379&gt; HSET website google &quot;www.g.cn&quot;       # 设置一个新域(integer) 1redis 127.0.0.1:6379&gt;HSET website google &quot;www.google.com&quot; # 覆盖一个旧域(integer) 0\n\nHset\n用于为哈希表中的字段赋值 \n如果字段已经存在于哈希表中，旧值将被覆盖\nredis 127.0.0.1:6379&gt; HSET myhash field1 &quot;foo&quot;OKredis 127.0.0.1:6379&gt; HGET myhash field1&quot;foo&quot;redis 127.0.0.1:6379&gt; HSET website google &quot;www.g.cn&quot;       # 设置一个新域(integer) 1redis 127.0.0.1:6379&gt;HSET website google &quot;www.google.com&quot; # 覆盖一个旧域(integer) 0\n\nHsetnx\n用于为哈希表中不存在的的字段赋值\n如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。\n如果字段已经存在于哈希表中，操作无效。\nredis 127.0.0.1:6379&gt; HSETNX myhash field1 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; HSETNX myhash field1 &quot;bar&quot;(integer) 0redis 127.0.0.1:6379&gt; HGET myhash field1&quot;foo&quot;\n\nHvals\n返回哈希表所有的值\nredis 127.0.0.1:6379&gt; HSET myhash field1 &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; HSET myhash field2 &quot;bar&quot;(integer) 1redis 127.0.0.1:6379&gt; HVALS myhash1) &quot;foo&quot;2) &quot;bar&quot;\n\nHscan\n用于遍历哈希表中的键值对\nHSCAN key cursor [MATCH pattern] [COUNT count]\n\n&gt; HMSET sites google &quot;google.com&quot; runoob &quot;runoob.com&quot; weibo &quot;weibo.com&quot; 4 &quot;taobao.com&quot;OK&gt; HSCAN sites 0 match &quot;run*&quot;1) &quot;0&quot;2) 1) &quot;runoob&quot;2) &quot;runoob.com&quot;\n\nlistBlpop\n移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止\nBrpop\n移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止\nbrpoplpush\n从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止\nLindex\n通过索引获取列表中的元素\nLinsert\n在列表的元素前或者后插入元素\nLlen\n获取列表长度\nLpop\n移出并获取列表的第一个元素\nLpush\n将一个或多个值插入到列表头部\nLpushex\n将一个值插入到已存在的列表头部\nLrange\n获取列表指定范围内的元素\nLrem\n移除列表元素\nLset\n通过索引设置列表元素的值\nLtrim\n让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除\nRpop\n移除列表的最后一个元素，返回值为移除的元素。\nRpoplpush\n移除列表的最后一个元素，并将该元素添加到另一个列表并返回\nRpush\n在列表中添加一个或多个值到列表尾部\nRpushex\n为已存在的列表添加值\n","categories":["Redis"],"tags":["Redis"]},{"title":"Redis配置","url":"/Fly_NBlog/2023/05/27/Redis%E9%85%8D%E7%BD%AE/","content":"简介一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API\nRedis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型\n使用场景\n缓存：热点数据缓存、对象缓存、全页缓存\n数据共享分布式\n分布式锁\n全局ID：分库分表、利用原子性\n计数器：文章阅读量、点赞数\n限流\n数据统计，通过二进制存储：在线用户统计\n购物车\n消息时间线\n消息队列\n抽奖\n点赞、签到、打卡\n商品标签\n商品筛选\n用户关注，推荐\n排行榜\n\n配置默认端口：6379\n配置文件，在安装目录\n\nLinux：redis.conf\nWindows：redis.windows.conf\n\nconfig命令通过config查看配置项，get获取，set设置\n//获取loglevel配置项config get loglevel//获取所有配置项config get *//设置loglevel配置项config set loglevel &quot;notice&quot;\n\n\n\nredis.conf参数说明\ndaemonize：no\n\n守护进程（精灵进程），默认为no，使用yes启用（windows不支持）\n后台服务进程，生存周期较长\n独立于控制终端，周期性执行某种任务或等待处理某些发生的事件\n脱离终端原因：避免被终端的任何信息打断，也不在任何终端显示\n\n\npidfile： /var/run/redis.pid\n\n启用守护线程，默认将pid写入redis.pid文件，可指定\n\n\nport：6379\n\n默认监听端口\n原因： 6379 在手机按键上 MERZ 对应的号码，意大利歌女Alessia Merz 的名字\n\n\nbind：127.0.0.1\n\n绑定主机地址\n\n\ntimeout：300\n\n客户端闲置多少秒后关闭链接，为0关闭此功能\n\n\nloglevel：notice\n\n日志记录级别，有四个值\ndebug、verbose、notice、warning，默认为notice\n\n\nlogfile：””\n\n日志记录方式，默认为标准输出\n启动守护进程，配置为标准输出，则日志会发送给 /dev/null\n\n\ndatabases：0\n\n数据库数量，默认为0\n\n使用select指定链接数据库id\n\n\n\nsave：900 1\n\n指定时间内（秒数），有多少次更新，就将数据同步到数据文件，可以多个条件配合\n\n默认三个条件：\n\nsave 900 1：900秒内有1个更改\n\nsave 300 10：300秒内有10个更改\n\nsave 60 10000：60秒内有10000更改\n\n\n\nrdbcompression：yes\n\n存储至本地数据库时是否压缩数据，默认为yes，采用LZF压缩\n\n节省cpu时间，但数据文件变巨大\n\n\n\ndbfilename：dump.rdb\n\n指定本地数据库文件名，默认值为：dump.rdb\n\n\ndir： ./\n\n指定本地数据库存放目录\n\n\nslaveof ： &lt;masterip&gt; &lt;masterport&gt;\n\n当本机为 slave 服务时，设置 master 服务的 IP 地址及端口\nRedis 启动时，自动从 master 进行数据同步\n默认：&quot;&quot;\n\n\nmasterauth： &lt;master-password&gt;\n\nmaster 服务设置了密码保护时，slave 服务连接 master 的密码\n\n\nrequirepass： foobared\n\nRedis 连接密码\n\n如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH &lt;password&gt; 命令提供密码\n\n默认关闭\n\n\n\nmaxclients ：128\n\n同一时间最大客户端连接数，默认无限制，为0\n\n客户端连接数到达限制，关闭新的连接并向客户端返回max number of clients reached 错误信息\n\n\n\nmaxmemory：&lt;bytes&gt;\n\n最大内存限制\n\n满内存，尝试清楚已到期或即将到期的key\n\n清除后还是满内存时，无法进行写操作，但可以进行读操作\n\n新vm机制，key存放内存区，value存放swap区\n\n\n\nappendonly：no\n\n默认为no\n\n是否在每次更新操作后进行日志记录\n\n默认情况下是异步的把数据写入磁盘\n\n如果不开启，可能会在断电时导致一段时间内的数据丢失\n\n同步数据文件是按save 条件来同步的，所以有的数据会在一段时间内只存在于内存中\n\n\n\nappendfilename：appendonly.aof\n\n更新日志文件名，默认值appendonly.aof\n\n\nappendfsync：everysec\n\n更新条件，3个默认值\nno：等操作系统进行数据缓存同步到磁盘（快）\nalways：每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）\neverysec：每秒同步一次（折中，默认值）\n\n\nvm-enabled：no\n\n是否启用虚拟内存，默认为no\n\n\nvm-swap-file：/tmp/redis.swap\n\n虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享\n\n\nvm-max-memory：0\n\n所有大于值的数据存入虚拟内存\n默认值为0，所有value都存磁盘\n\n\nvm-page-size：32\n\n默认值32\n一个对象可以保存在多个page上，一个page不能被多个对象共享\n根据存储数据大小决定\n存储小对象设置为32或64\n\n\nvm-pages：123456\n\n默认值为空list或set\n设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，在磁盘上每 8 个 pages 将消耗 1byte 的内存\n\n\nvm-max-threads：4\n\n设置访问swap文件的线程数，最好不要超过机器的核数\n设置为0，所有对swap文件的操作都是串行\n默认值为4\n\n\nglueoutputbuf：yes\n\n向客户端应答时，是否把较小的包合并为一个包发送\n默认为开启\n\n\nhash-max-zipmap-entries 64hash-max-zipmap-value 512\n\n超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法\n\n\nactiverehashing： yes\n\n是否激活重置哈希，默认为开启\n\n\ninclude ：/path/to/local.conf\n\n指定包含其它的配置文件\n可以在同一主机上多个Redis实例之间使用同一份配置文件\n各个实例又拥有自己的特定配置文件\n\n\n\n","categories":["Redis"],"tags":["Redis"]},{"title":"TypeScript笔记(一)","url":"/Fly_NBlog/2021/10/31/TypeScript%E7%AC%94%E8%AE%B0(%E4%B8%80)/","content":"什么是TypeScript?JavaScript的超集，支持ES6，设计目标是开发大型应用\n基础类型//anylet txt:any = &#x27;ts&#x27;;//numberlet num:number = 1;//stringlet str:string = &#x27;string&#x27;;//booleanlet b:boolean = true;//数组let arr:number[] = [1,2];//使用泛型let arr:Array&lt;number&gt; = [1,2];//元组let x:[string,number]x = [&#x27;Tom&#x27;,24];x = [24,&#x27;Tom&#x27;]; //报错//枚举enumenum Color &#123;Red,Green,Blue&#125;;let blue = Color.Blue;//voidfunction hello():void &#123;    console.log(&#x27;hello&#x27;);&#125;//nulllet x:string | null;//undefinedlet x:number | null | undefined//never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值\n\n","categories":["TypeScript"],"tags":["TypeScript"]},{"title":"Vue2笔记(一)","url":"/Fly_NBlog/2021/11/11/Vue2%E7%AC%94%E8%AE%B0(%E4%B8%80)/","content":"初识Vue安装使用CDN（最新版本）\n&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;\n\n使用npm\n$ npm install vue\n\n使用Vue-Cli\n$ npm install -g @vue/cli\n\n基本使用准备好一个容器\n&lt;div id=&quot;app&quot;&gt;   &lt;h1&gt;    \t&#123;&#123;msg&#125;&#125;   &lt;/h1&gt;&lt;/div&gt;\n\n创建vue实例\n&lt;script type=&quot;text/javascript&quot;&gt;    Vue.config.productionTip = false;\t//阻止vue在启东市生成生产提示\t//创建Vue实例    new Vue(&#123;        el: &#x27;#app&#x27;,\t//el用于指定当前Vue实例为哪个容器服务，值为CSS选择器字符串        data: &#123;\t            //data中用于存储数据，数据供el所指定的容器使用，值暂时写为对象            msg: &quot;Hello World&quot;        &#125;    &#125;)&lt;/script&gt;\n\n\n总结：\n\n要让Vue工作，必须创建一个Vue实例，并传入一个配置对象\nroot容器里的代码依然符合html规范，只是混入了一些特殊的vue语法\nroot容器里的代码称为Vue模板\nVue实例和容器是一一对应的\n真实开发中只有一个Vue实例，并且配合组件一起使用\n&#123;&#123;xxx&#125;&#125;中的xxx要写js表达式，xxx可以自动读取到data中的所有属性\ndata中的数据发生改变，页面中用到该数据的地方会自动更新\n\n补充：js表达式和js代码（语句）的区分\n表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方\n\na\na + b\ndemo(1)\nx === y ? &#39;a&#39; : &#39;b&#39;\n\njs代码（语句）：\n\nif()&#123;&#125;\nfor()&#123;&#125;\n\n\n模板语法插值语法用于解析标签体内容，写法&#123;&#123;xxx&#125;&#125;，xxx是js表达式，可以直接读取data中的所有属性\n&lt;div id=&quot;app&quot;&gt;    &lt;h1&gt;插值语法&lt;/h1&gt;   \t&lt;h3&gt;Hello,&#123;&#123;msg&#125;&#125;&lt;/h3&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;\tVue.config.productionTip = false;    new Vue(&#123;        el: &quot;app&quot;,        data: &#123;            msg: &quot;World&quot;        &#125;    &#125;)&lt;/script&gt;\n\n指令语法用于解析标签（包括：标签属性、标签体内容、绑定事件等），\n例如： v-bind:href=&quot;xxx&quot; 或简写为 :href=&quot;xxx&quot; ，这里的xxx同样要写js表达式\n&lt;a v-bind:href=&quot;www.bilibili.com&quot;&gt;点我去bilibili&lt;/a&gt;&lt;a :href=&quot;www.bilibili.com&quot;&gt;点我去bilibili&lt;/a&gt;&lt;a :href=&quot;location.url&quot;&gt;点我去&#123;&#123;location.name&#125;&#125;&lt;/a&gt;\n\nVue中还有很多的指令，形式都是： v-??? 开头\n数据绑定Vue中有2中数据绑定方式：\n\n单向绑定（v-bind），数据只能从data流向页面。\n双向绑定（v-model），数据不仅能从data流向页面，还可以从页面流向data\n\n\n补充：\n\n双向绑定一般用在表单类元素上（input、select等）\nv-model:value 可以简写为v-model，默认收集的就是value值\n\n\n单向数据绑定普通写法：\n&lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot; /&gt;\n\n简写：\n&lt;input type=&quot;text&quot; :value=&quot;name&quot; /&gt;\n\n双向数据绑定普通写法：\n&lt;input type=&quot;text&quot; v-model:value=&quot;name&quot;/&gt;\n\n简写：\n&lt;input type=&quot;text&quot; v-model=&quot;name&quot; /&gt;\n\nel与data的两种写法el\nnew Vue的时候配置el属性\n先创建Vue实例，然后通过vm.$mount(&#39;#root&#39;)指定el的值\n\n&lt;div id=&#x27;root&#x27;&gt;\t&lt;h1&gt;        &#123;&#123;msg&#125;&#125;    &lt;/h1&gt;    &lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    const app = new Vue(&#123;        //第一种写法，配置el属性        el: &#x27;#root&#x27;,        data: &#123;            msg: &quot;Hello World&quot;        &#125;    &#125;)    console.log(app);\t//控制台打印Vue实例    app.$mount(&#x27;#app&#x27;);\t//第二种写法&lt;/script&gt;\n\ndata\n对象式 data: &#123; msg: &quot; Hello World &quot; &#125;\n函数式 data()&#123; return &#123; msg: &quot;Hello World&quot; &#125; &#125;\n\n&lt;script&gt;\tconst app = new Vue(&#123;        //对象式data        data: &#123;            msg: &quot;Hello World&quot;        &#125;    &#125;)    app.$mount(&#x27;#root&#x27;);        const app1 = new Vue(&#123;        el: &#x27;#root&#x27;,        data()&#123;            console.log(this);\t//这里的this是Vue实例对象（vm）            return &#123;                msg: &quot;Hello World&quot;            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n\n重要的原则：由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。\n\nVue中的MVVMMVVM\nM：模型（model），指的是data中的数据\nV：视图（view），模板代码\nVM（viewmodel），Vue实例\n\n&lt;div id=&quot;root&quot;&gt;    &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;\t&lt;h1&gt;&#123;&#123;1+1&#125;&#125;&lt;/h1&gt;\t&lt;h1&gt;&#123;&#123;$options&#125;&#125;&lt;/h1&gt;\t&lt;h1&gt;&#123;&#123;$emit&#125;&#125;&lt;/h1&gt;    &lt;h1&gt;&#123;&#123;_c&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;\tVue.config.productionTio = false;    const vm = new Vue(&#123;        el: &#x27;#root&#x27;,        data: &#123;            msg: &quot;Hello World&quot;        &#125;    &#125;)    console.log(vm);&lt;/script&gt;\n\n\n观察得：\n\ndata中的所有属性，都出现在vm身上\nvm身上的所有属性以及Vue原型上的所有属性，在Vue模板中都可以使用\n\n\n","categories":["Vue"],"tags":["Vue2"]},{"title":"Vue2笔记（二）","url":"/Fly_NBlog/2021/12/05/Vue2%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"数据代理Object.defineProperty该方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象\nObject.definProperty(obj , propertyName , attributesObject)\n\n接受三个参数，依次是\n\nobject：属性所在的对象\npropertyName：字符串，表示属性名\nattributesObject：属性描述对象\n\n举个例子：\nlet number = 18;let person = &#123;    name: &quot;张三&quot;,    sex: &quot;男&quot;&#125;Object.definProperty(person, &#x27;age&#x27;, &#123;    value: age,    enumerable: true,\t//控制属性是否可以枚举，默认为false    writable: true,\t\t//控制属性是否可以被修改，默认为false    configurable: true\t//控制属性是否可以被删除，默认为false&#125;)\n\n上面代码中，定义了一个对象person，然后通过Object.definProperty为person定义了一个属性age，age的值是上述声明的number，也就是18。并通过属性描述对象的enumerable、writable、configurable属性为true。\n一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，或者同时定义value属性，否则会报错\nObject.definProperty(person, age, &#123;    get()&#123;        console.log(&quot;读取了age属性&quot;);        return number;    &#125;,    set(value)&#123;        console.log(&quot;修改了age属性，值为&quot;,value);        number = value;    &#125;&#125;)\n\nObject.defineProperties如果需要一次性定义或修改多个属性，可以使用Object.defineProperties\nlet obj - Object.definProperties(&#123;&#125;, &#123;    p1: &#123; value: 123, enumerable: true&#125;,    p2: &#123; value: &#x27;abc&#x27;, writable: true&#125;,    p3: &#123; get:function()&#123; return this.p1 + this.p2 &#125;,        enumerable: true, configurable: true&#125;&#125;)\n\n什么是数据代理通过一个对象，代理另一个对象中属性的操作（读 &#x2F; 写）\nlet obj = &#123; x: 100 &#125;let obj2 = &#123; y: 200 &#125;Object.definProperty(obj2, x ,&#123;    get()&#123;        return obj.x    &#125;,    set(value)&#123;        obj.x = value    &#125;&#125;)\n\nVue中的数据代理通过vm对象来代理data对象中属性的操作（读 &#x2F; 写），更加方便的操作data中的数据。\n基本原理：\n\n通过Object.definProperty()把data对象中所有属性添加到vm上\n为每一个添加到vm上的属性，都指定一个getter / setter\n在getter / setter内部去操作（读 &#x2F; 写）data中对应的属性\n\n事件处理事件的基本使用\n使用v-on:xxx或@xxx绑定事件，其中xxx是事件名\n事件的回调需要配置在methods对象中，最终会出现在vm上\nmethods中配置的函数，不要使用箭头函数！否则this就不是vm\nmethods中配置的函数，都是被Vue所管理的函数，this的指向是vm或组件实例对象\n@click=&quot;demo&quot;和@click=&quot;demo($event)&quot;效果一样，后者可以传参\n\n&lt;div id=&quot;root&quot;&gt;    &lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;    &lt;!-- &lt;button v-on:click=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt; --&gt;    &lt;button @click=&quot;showInfo1&quot;&gt;点我提示信息1（不传参）&lt;/button&gt;    &lt;button @click=&quot;showInfo2($event,66)&quot;&gt;点我提示信息2（传参）&lt;/button&gt;&lt;/div&gt;&lt;script&gt;    Vue.confit.productionTip = false;        const vm = new Vue(&#123;        el: &quot;#root&quot;,        data: &#123;            msg: &quot;事件基本使用&quot;        &#125;,        methods:&#123;            showInfo1(event)&#123;                console.log(event)                console.log(this) //此处的this是vm                alert(&quot;没有传参&quot;)            &#125;,            showInfo2(event, val)&#123;                console.log(event,val)                alert(&quot;传了一个参&quot;,val)            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n事件修饰符\nprevent：阻止默认事件（常用）\nstop：阻止事件冒泡（常用）\nonce：事件只触发一次（常用）\ncapture：使用事件的捕获模式\nself：只有even.target是当前操作的元素时才触发\npassive：事件的默认行为，立即执行，无需等待事件回调执行完毕\n\n&lt;button @click.prevent=&quot;OnHandle&quot;&gt;阻止默认事件&lt;/button&gt;&lt;div @click=&quot;ParentHandle&quot;&gt;    &lt;button @click.stop=&quot;OnHandle&quot;&gt;阻止事件冒泡&lt;/button&gt;&lt;/div&gt;&lt;button @click.once=&quot;OnHandle&quot;&gt;事件只触发一次&lt;/button&gt;&lt;div @click.captrue=&quot;showMsg(1)&quot;&gt;    &lt;div @click=&quot;showMsg(2)&quot;&gt;使用事件的捕获模式&lt;/div&gt;&lt;/div&gt;&lt;div @click.self=&quot;OnHandle&quot;&gt;    &lt;div @click=&quot;OnHandle&quot;&gt;只有event.target是当前操作的元素时才触发事件&lt;/div&gt;&lt;/div&gt;&lt;ul @wheel.passive=&quot;OnHandle&quot;&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;    &lt;li&gt;4&lt;/li&gt;    &lt;li&gt;事件的默认行为立即执行，无需等待事件回调执行完毕&lt;/li&gt;&lt;/ul&gt;\n\n键盘事件Vue中常用的按键别名\n\n\n\n名称\n按键\n\n\n\n回车\nenter\n\n\n删除\ndelete（捕获删除或退格键）\n\n\n退出\nesc\n\n\n空格\nspace\n\n\n换行\ntab（特殊，必须配合keydown去使用）\n\n\n上\nup\n\n\n下\ndown\n\n\n左\nleft\n\n\n右\nright\n\n\nVue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为\nkebab-case（短横线命名）\n&lt;div id=&quot;root&quot;&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;按下回车提示输入&quot; @keydown.huiche=&quot;onHandle&quot; /&gt;&lt;/div&gt;&lt;script&gt;    Vue.config.keCodes.huiche = 13;\t\t//定义一个别名按键    const vm = new Vue(&#123;        el: &quot;#app&quot;,        methods: &#123;            onHandle(e)&#123;                console.log(e.target.value)            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n系统修饰键（用法特殊）\n\nctrl、alt、shift、meta\n配合keydown使用，按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发\n也可以使用keyCode去指定具体的按键（不推荐）\n用法：Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名\n\n计算属性要用的属性不存在，要通过已有属性计算得来。底层借助了Object.defineProperty提供的getter和setter\nget函数在初次读取时会执行一次，当依赖的数据发生改变时会被再次调用\n与methods相比，内部有缓存机制（复用），效率高、调试方便\nconst vm = new Vue(&#123;\tel: &quot;#root&quot;,    data: &#123;        firstName: &quot;张&quot;,        lastName: &quot;三&quot;    &#125;,    computed: &#123;        fullName:&#123;            get()&#123;                console.log(&quot;get被调用&quot;)                return this.firstName + &#x27;-&#x27; + this.lastName            &#125;,            set(val)&#123;                console.log(&quot;set被调用，值是&quot;,val)                let arr = val.split(&#x27;-&#x27;)                this.firstName = arr[0]                this.lastName = arr[1]            &#125;        &#125;    &#125;&#125;)\n\n\n计算属性最终会出现在vm上，直接读取即可。如果计算属性要被修改，必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变\n\n上面的代码使用的是计算属性的完整写法，下面使用简写\nconst vm = new Vue(&#123;\tel: &quot;#root&quot;,    data: &#123;        firstName: &quot;张&quot;,        lastName: &quot;三&quot;    &#125;,    computed: &#123;        /* fullName:&#123;            get()&#123;                console.log(&quot;get被调用&quot;)                return this.firstName + &#x27;-&#x27; + this.lastName            &#125;,            set(val)&#123;                console.log(&quot;set被调用，值是&quot;,val)                let arr = val.split(&#x27;-&#x27;)                this.firstName = arr[0]                this.lastName = arr[1]            &#125;        &#125; */        fullName: &#123;            console.log(&quot;get被调用&quot;);        \treturn this.firstName + &#x27;-&#x27; + this.lastName;        &#125;    &#125;&#125;)\n\n","categories":["Vue"],"tags":["Vue2"]},{"title":"Webpack基础","url":"/Fly_NBlog/2021/12/03/Webpack%E5%9F%BA%E7%A1%80/","content":"目标\nWebpack常规配置有哪些？\n常用Loader有哪些？如何配置？\n常用插件(Plugin)有哪些？如何配置？\nBabel的如何配置？Babel插件如何使用？\n\n安装\n本地安装webpack以及webpack-cli\n\n$ npm install webpack webpack-cli -D #安装到本地依赖\n\n安装完成\n\n+ webpack-cli@4.9.1+ webpack@5.64.4\n\n简单配置工作模式webpack在4以后支持0配置打包，可以测试一下\n\n新建 ./src/index.js 文件，编写一点简单的代码\nconst a = &quot;Hello Webpack&quot;;console.log(a);module.export = a;\n\n此时的目录结构\nStudy Webpack├── package-lock.json├── package.json└── src    └── index.js\n\n直接运行 npx webpack ，启动打包\nasset main.js 302 bytes [emitted] [minimized] (name: main)runtime modules 123 bytes 1 module./src/index.js 63 bytes [built] [code generated]WARNING in configurationThe &#x27;mode&#x27; option has not been set, webpack will fallback to &#x27;production&#x27; for this value.Set &#x27;mode&#x27; option to &#x27;development&#x27; or &#x27;production&#x27; to enable defaults for each environment.You can also set it to &#x27;none&#x27; to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/webpack 5.64.4 compiled with 1 warning in 236 ms\n\n打包完成，可以看到日志上有一段提示：The &#39;mode&#39; option has not been set \n意思就是，没有配置mode（模式），提醒我们配置\n\n模式：供mode配置选项，告知webpack使用相应模式的内置优化，默认值为 production ，另外还有 development 、none 他们的区别如下\n\n\n\n\n选项\n描述\n\n\n\ndevelopment\n开发模式，打包更快，省去代码优化\n\n\nproduction\n生产模式，打包较慢，开启tree-shaking和压缩代码\n\n\nnone\n不适用任何默认优化选项\n\n\n怎么配置？\n\n在配置对象中提供mode选项：\nmodule.export = &#123;    mode: &#x27;development&#x27;,&#125;\n\n从CLI参数中传递：\n$ npx webpack --mode=development\n\n\n\n配置文件虽然可以0配置打包，但是实际开发中，还是需要使用配置文件的方式，来满足不同的项目需求。\n\n根路径下新建一个配置文件webpack.config.json\n\n新增基本配置信息\nconst path = require(&#x27;path&#x27;);module.export = &#123;    mode: &#x27;development&#x27;, //模式    entry: &#x27;./src/index.js&#x27;, //打包入口地址    output: &#123;        filename: &#x27;bundle.js&#x27;, //输出文件名        path: path.join(__dirname, &#x27;dist&#x27;) //输出文件目录    &#125;&#125;\n\n致此，一些最基本的配置就已完成\n\n\n","categories":["Webpack"],"tags":["Webpack"]},{"title":"华为1+X移动应用中级（一）","url":"/Fly_NBlog/2021/11/15/%E5%8D%8E%E4%B8%BA1+X%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E4%B8%AD%E7%BA%A7%EF%BC%88%E4%B8%80%EF%BC%89/","content":"Java基础Java三个主要版本\nJava SE：标准版，用于桌面应用程序开发，也是Java的基础\nJava EE：企业版，用于开发企业级分布式的网络程序\nJava ME：用于嵌入式系统开发，需要底层操作系统支持\n\n特性\n简单的（simple）\n面向对象的（object-oriented）\n分布式的（distributed）\n解释性的（interpreted）\n健壮的（robust）\n安全的（secure）\n结构中立的（architecture neutral）\n便捷的（portable）\n高性能的（high-performance）\n多线程的（multithreaded）\n动态的（dynamic）\n\n面向对象编程\n面向过程（Procedure Oriented Programming）简称 POP\n基础的顺序思维，过程为中心\n核心问题是数据结构和算法的开发和优化\n\n\n面向对象（Object Oriented Programming）简称 OOP\n按客观世界思维方式，以对象为中心\n直接重现问题中各个对象之间的关系\n基本特性：抽象、继承、封装、多态\n\n\n\n标识符、注释\n标识符由数字、字母、下划线、美元符组成\n严格区分大小写\n\n注释\n单行注释：&#x2F;&#x2F;开头\n//这是一行注释\n\n多行注释：“ &#x2F;* “开头，” *&#x2F; “结尾\n/*\t这是一块注释*/\n\n文档注释：“ &#x2F;** ” 开头，“ *&#x2F; ”结尾\n/**\t@value 这是文档注释*/\n\n常量、变量常量\n使用前必须定义，需要初始化\n\n初始化后不可修改\n\n使用final关键字定义\nfinal String STR = &quot;这是一个常量&quot;;\n\n常用大写字母表示，区分变量\n\n静态常量定义\nfinal static String STR = &quot;这是一个静态常量&quot;;\n\n常量值\n整型：十进制、八进制（0开头）、十六进制（0X或0x开头）\n\n长整型：整型后面以 L 结尾\nint testNumber = 12;\t//整型int testNumber2 = 12L;\t //长整型\n\n浮点型：十进制由数字和小数点组成，科学记数法其中e或E之前必须有数字，之后的数字必须为整数\nfloat num1 = 1.2;\t //十进制float num2 = 1.25e3;\t //科学记数法\n\n布尔型：true或false\nboolean val = true;boolean val2 = false;\n\n字符型：单引号括起来的单个字符（数据类型为char）以及转义字符（以 \\ 开头的字符序列）\nchar c = 97;\t//A\n\n字符串：双引号括起来的若干个字符\nString str = &quot;hello world&quot;;\n\n转义字符：\n/* \t\\r 回车\t\\n 换行\t\\f 走纸换页\t\\t 和tab一样\t\\b 退格\t\\ddd 1-3位八进制表示的字符 如\\456\t\\uxxxx 1-4位十六进制表的字符 如 \\u0d60\t\\&#x27; 单引号字符\t\\&quot; 双引号字符\t\\\\ 反斜杠字符*/\n\n变量基本数据类型整数类型| 数据类型 | 字节数 | 位数 |     取值范围     | 包装类  | 默认值 || :------: | :----: | :--: | :--------------: | :-----: | :----: ||   byte   |   1    |  8   |  -2^7^ ~ 2^7^-1  |  Byte   |   0    ||  short   |   2    |  16  | -2^15^ ~ 2^15^-1 |  Short  |   0    ||   int    |   4    |  32  | -2^31^ ~ 2^31^-1 | Integer |   0    ||   long   |   8    |  64  | -2^63^ ~ 2^63^-1 |  Long   |   0L   |\n\n浮点数类型| 数据类型 | 字节数 | 位数 |     取值范围     | 包装类 | 默认值 || :------: | :----: | :--: | :--------------: | :----: | :----: ||  float   |   4    |  32  |  -3.4E38~3.4E38  | Float  |  0.0f  ||  double  |   8    |  64  | -1.8E308~1.8E308 | Double |  0.0d  |\n\n字符类型| 数据类型 | 字节数 | 位数 |      取值范围      |  包装类   |  默认值  || :------: | :----: | :--: | :----------------: | :-------: | :------: ||   char   |   2    |  16  | &#x27;\\u000&#x27; ~ &#x27;\\uffff&#x27; | Character | &#x27;\\u0000&#x27; |\n\n布尔类型| 数据类型 | 字节数 | 位数 |  取值范围  | 包装类  | 默认值 || :------: | :----: | :--: | :--------: | :-----: | :----: || Boolean  |   1    |  8   | true,false | Boolean | false  |\n\n","categories":["HarmonyOS开发"],"tags":["HarmonyOS","Java基础"]},{"title":"数据库","url":"/Fly_NBlog/2023/06/02/%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"基本术语\n关系：二维表\n元组：表中的一行\n属性：表中的列的名称\n关系模式：对关系的描述，格式：关系名（属性1，属性2….，属性n）\n候选码（候选键）：属性或属性组合，唯一标识一个元组\n主码（主键）：一个关系有多个候选码，选一个做主码\n主属性：所有候选键都是主属性，其他都是非主属性\n超码（超键）：例学号是码，则（学号，姓名）是超码\n\n数据模型的分类概念数据模型从信息世界中抽象的数据模型，一般采用实体-联系方法（E-R方法）表示\nE-R方法简称E-R图，其中\n\n实体：矩形表示\n属性：椭圆表示\n联系：菱形表示\n\n结构数据模型从计算机中抽象出的DBMS支持的数据模型\n主要包括：层次、网状、关系和面向对象模型\n关系模式（表）：二维表格描述实体与实体之间联系的数据模型\n三级模式和两级映射三级模式外模式（用户模式或子模式）——视图\n概念模式（模式）——基本表\n内模式（存储模式）——存储文件\n两级映射物理独立性：模式&#x2F;内模式映射，需要修改概念模式和内模式之间的转换\n逻辑独立性：外模式&#x2F;模式映射，需要修改外模式和概念模式之间的转换\n完整性约束\n实体完整性：主键不能为空\n参照完整性：外键可以为空，但必须在另外一个表中存在\n用户自定义完整性\n\n","categories":["软件设计师"],"tags":["数据库","软件设计师"]},{"title":"欢迎来到我的博客","url":"/Fly_NBlog/2021/10/31/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/","content":"内容介绍对技术内容做一个简单性的总结\n","categories":["博客介绍"]},{"title":"面向对象","url":"/Fly_NBlog/2023/06/05/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","content":"面向对象对象+分类+继承+通过消息的通信\n采用这4个概念开发的系统是面向对象的\n对象一个程序模块\n由对象名、属性、方法3个构成\n消息对象之间的一种通信\n重载方法名相同，但参数不同\n封装目的：使对象的生产者和使用者分离，对象的定义和实现分离\n继承父类描述了子类的公共属性和方法\n重写（覆盖）子类重写父类的方法\n绑定把过程调用和响应调用所需要执行的代码加以结合的过程\n静态绑定绑定在编译时运行\n动态绑定运行时进行\n设计原则单一责任SRP一个类只做一种类型的责任，且需要修改某个类的原因有且只有一个\n开放-封闭OCP对扩展开放，对修改封闭\n里氏替换LSP子类必须能够替换基类，它们之间是一种is-a关系\n依赖倒置DIP抽象不应该依赖细节，细节应该依赖抽象。\n高层模块不依赖低层模块，二者依赖抽象\n接口分离ISP依赖抽象，不依赖具体\n在抽象级别不应该有对于细节的依赖\n面向对象分析OOA目的：获得对应用问题的理解\n包含5个活动：\n\n认定对象\n组织对象\n描述对象间的相互作用\n确定对象的操作\n定义对象的内部信息\n\n面向对象设计OOD将OOA的分析模型转为设计模型\n同样遵循：抽象、信息隐蔽、功能独立、模块化\n在OOA的模型基础上，有5个活动：\n\n识别类与对象\n定义属性\n定义服务\n识别关系\n识别包\n\n面向对象程序设计OOP采用一种面向对象的设计语言\n","categories":["软件设计师"],"tags":["软件设计师","面向对象"]}]